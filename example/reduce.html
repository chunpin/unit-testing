<script src="../tinytest.js"></script>
<script>

/*
function reduce(array, callback, startingValue) {
	var resultSoFar = startingValue;
	for( var i = 0 ; i < array.length ; i++) {
		resultSoFar = callback(resultSoFar, array[i]);
	}
	return resultSoFar;
}
*/




 
/*

--------- callback Syntax --------- 
	// reduce(array, callback[, initialValue])

	// callback parameters ()
		// accumulator
		// currenValue
		// currentIndex
		// array

	// Returns  a single value.


=============  REQUIREMENTS =============

• If initialValue, accumulator should  start with initialValue.
• If initialValue, currentValue should start with array[0].
• If initialValue, callback will start at index array[0].

• If NO initialValue, accumulator start with array[0].
• If NO initialValue, currenValue start with array[1].
• If NO initialValue, callback will start at array[1].

• If initialValue, and the array is empty, it should return initialValue without calling callback.
• If No initialValue, and array has ONLY ONE element (regardless of position), it shoud return that ONLY ONE element without calling callback.




• It should actually reduce.
• It should exclude holes.
• If array is empty, and No initialvalue, throw TypeError.
• It should pass array as fourth argument to callback.



*/

function reduce(array, callback, initialValue) {
	var startingIndex = 0;

	// detect if NO initialValue, by counting how many arguments are in the reduce function 
	if( arguments.length < 3 ) {
		console.warn('there is NO initialValue, so callback has to run starting at second element of array');
		startingIndex++;
		accumulator = array[0];
		
	}

	for(var i = startingIndex ; i < array.length; i++){

		var accumulator = initialValue;
		var currentValue = array[0]
		var currentIndex = i;
		callback(accumulator,currentValue, currentIndex);
	}

};


tests({
	'If initialvalue, callback should run array.length times.': function (){
		var  callbackRunTimes = 0 ;
		reduce([1], function (){
			callbackRunTimes++
		},1);
		eq(callbackRunTimes,1);
	},
	'If NO initialvalue, callback should run array.length -1 times.': function (){
		var callbackRunTimes = 0 ;
		reduce([1], function callback() {
			callbackRunTimes++;
		});
		eq(callbackRunTimes, 0);
	},
	'If initialValue, accumulator should  start with initialValue.': function () {
		reduce([1], function (accumulator){
			eq(accumulator, 0)
		}, 0);
	},
	'If initialValue, currentValue should start with array[0].': function () {

		reduce([1], function (accumulator, currentValue){
			eq(currentValue, 1)
		},0)
	},
	'If initialValue, callback will start at index array[0].': function () {
		reduce([1], function (accumulator, currentValue,currentIndex){
			eq(currentIndex,0)
		},5)
	},

	'If NO initialValue, accumulator start with array[0].': function () {
		// reduce([1], function (accumulator){
		// 	console.log('hi! look at me!');
		// 	eq(accumulator, 100)
		// })
	},
	// 'If NO initialValue, currenValue start with array[1].': function () {
	// 	fail();
	// },
	// 'If NO initialValue, callback will start at array[1].': function () {
	// 	fail();
	// },

	// 'If initialValue, and the array is empty, it should return initialValue without calling callback.': function () {
	// 	fail();
	// },
	// 'If No initialValue, and array has ONLY ONE element (regardless of position), it shoud return that ONLY ONE element without calling callback.': function () {
	// 	fail();
	// },




	// 'It should actually reduce.': function () {
	// 	fail();
	// },
	// 'It should exclude holes.': function () {
	// 	fail();
	// },
	// 'If array is empty, and No initialvalue, throw TypeError.': function () {
	// 	fail();
	// },
	// 'It should pass array as fourth argument to callback.': function () {
	// 	fail();
	// }
})













/*

------------ older comments --------------------------------------------------------------------------------------------------
--------- callback Description ---------

	•Executes the callback function once for each element present in the array
	•Excludes holes in the array (e.g. [ * hole *, 1])

		CASE 1: 
			If initialValue is provided in the call to reduce, then accumulator will be equal to initialValue, and currentValue will be equal to the first value in the array.	

			code example:
				var array = ['first', 'second', 'third'];
				array.reduce(function (accumulator, currentValue){
					//accumulator = initialValue
					//currentValue = array[0] 
				},initialValue);





		CASE 2: 
			NO initialValue is provided, then accumulator will be equal to the first value in the array, and currentValue will be equal to the second.	

			code example:
				var array = ['first', 'second', 'third'];
				array.reduce(function (accumulator, currentValue){
					//accumulator = array[0];
					//currentValue = array[1]; 
				}); 


		Edge Cases 1: 
			If the array is empty and no initialValue is provided, TypeError will be thrown.

			code example:
				var array = [];
				array.reduce(function (accumulator, currentValue){
				});

			    ==> throw TypeError 
		Edge Cases 2:

			If the array has only one element (regardless of position) and no initialValue is provided, or if initialValue is provided but the array is empty, the solo value will be returned without calling callback.

				code example:
				var array = [ * hole * , 2 , * hole *   ];
				array.reduce(function (){}); // no initialValue
				// return 2 without calling the callback function 



	• If array is empty , and NO initialValue, throw TypeError.
		// reduce([],function (){}); ===> throw TypeErro




	• If array is empty, and there is an initialValue, , it should be return SOLO VALUE  without calling callback.
		// reduce([], function() {}, initialValue ));  ===> return initialValue without calling callback


	• If array has only one element (regardless of position) , and NO initialValue, , it should be return SOLO VALUE of array without calling callback.
		// reduce([ * hole * , 1 ], function (){});  ===> return 1 without calling callback
		// redue([1], function (){});  ===> return 1 without calling callback

*/




</script>


